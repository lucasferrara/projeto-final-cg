<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Restaurante - Mesas 3D WebGL</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { width: 100vw; height: 100vh; display: block; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script>
// ================== SETUP ====================
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
window.onresize = resize;

if (!gl) alert("WebGL não suportado");

// =============== SHADERS =====================
const vsSrc = `
attribute vec3 position;
attribute vec3 color;
uniform mat4 projection;
uniform mat4 view;
varying vec3 vColor;
void main() {
    vColor = color;
    gl_Position = projection * view * vec4(position, 1.0);
}
`;

const fsSrc = `
precision mediump float;
varying vec3 vColor;
void main() {
    gl_FragColor = vec4(vColor, 1.0);
}
`;

function compile(src,type){
    const s = gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    return s;
}

const vs = compile(vsSrc,gl.VERTEX_SHADER);
const fs = compile(fsSrc,gl.FRAGMENT_SHADER);

const program = gl.createProgram();
gl.attachShader(program,vs);
gl.attachShader(program,fs);
gl.linkProgram(program);
gl.useProgram(program);

// ================= MATRIZES ===================
function perspective(fov,aspect,near,far){
    const f = 1.0 / Math.tan(fov/2);
    return new Float32Array([
        f/aspect,0,0,0,
        0,f,0,0,
        0,0,(far+near)/(near-far),-1,
        0,0,(2*far*near)/(near-far),0
    ]);
}
function translate(x,y,z){ 
    return [x,y,z]; 
}

let camPos = [0,1.2,5];
let projection;

// =============== GEOMETRIA ===============
let vertices = [];
let colors = [];

function quad(a,b,c,d,color){
    vertices.push(...a, ...b, ...c,  ...a, ...c, ...d);
    for (let i=0;i<6;i++) colors.push(...color);
}

// Piso
quad([-5,0,0],[5,0,0],[5,0,-80],[-5,0,-80],[0.82,0.82,0.75]);

// Teto
quad([-5,3,0],[5,3,0],[5,3,-80],[-5,3,-80],[0.9,0.88,0.85]);

// Paredes
quad([-5,0,0],[-5,3,0],[-5,3,-80],[-5,0,-80],[0.95,0.9,0.85]);
quad([5,0,0],[5,3,0],[5,3,-80],[5,0,-80],[0.95,0.9,0.85]);

// Parede do fundo
quad([-5,0,-80],[5,0,-80],[5,3,-80],[-5,3,-80],[0.95,0.95,0.95]);


// ============ OBJETO MESA 3D =============
function addCube(x,y,z, w,h,d, color) {
    // 8 vértices
    const v = [
        [x-w, y-h, z-d], // 0
        [x+w, y-h, z-d], // 1
        [x+w, y+h, z-d], // 2
        [x-w, y+h, z-d], // 3
        [x-w, y-h, z+d], // 4
        [x+w, y-h, z+d], // 5
        [x+w, y+h, z+d], // 6
        [x-w, y+h, z+d], // 7
    ];

    // faces do cubo
    quad(v[0],v[1],v[2],v[3],color); // frente
    quad(v[1],v[5],v[6],v[2],color); // direita
    quad(v[5],v[4],v[7],v[6],color); // trás
    quad(v[4],v[0],v[3],v[7],color); // esquerda
    quad(v[3],v[2],v[6],v[7],color); // cima
    quad(v[0],v[4],v[5],v[1],color); // baixo
}

function addTable(x,z){
    const tableColor = [0.7,0.4,0.2];
    const legColor = [0.4,0.25,0.15];

    // Tampo da mesa
    addCube(x, 0.85, z, 0.7, 0.1, 0.7, tableColor);

    // Pernas da mesa
    const h = 0.8;
    const s = 0.05;
    addCube(x-0.55, h/2, z-0.55, s, h/2, s, legColor);
    addCube(x+0.55, h/2, z-0.55, s, h/2, s, legColor);
    addCube(x-0.55, h/2, z+0.55, s, h/2, s, legColor);
    addCube(x+0.55, h/2, z+0.55, s, h/2, s, legColor);
}

// Distribuição de mesas 3D
for (let i = 6; i < 75; i += 8) {
    addTable(-2, -i);
    addTable( 2, -i - 3);
}

// =============== BUFFERS ===============
const bPos = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,bPos);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(vertices),gl.STATIC_DRAW);

const bCol = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,bCol);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(colors),gl.STATIC_DRAW);

const aPos = gl.getAttribLocation(program,"position");
gl.bindBuffer(gl.ARRAY_BUFFER,bPos);
gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,0,0);
gl.enableVertexAttribArray(aPos);

const aCol = gl.getAttribLocation(program,"color");
gl.bindBuffer(gl.ARRAY_BUFFER,bCol);
gl.vertexAttribPointer(aCol,3,gl.FLOAT,false,0,0);
gl.enableVertexAttribArray(aCol);

// ============== LOOP ==================
function draw(){
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);

    projection = perspective(60*Math.PI/180, canvas.width/canvas.height,0.1,200);
    gl.uniformMatrix4fv(gl.getUniformLocation(program,"projection"),false,projection);

    // matriz view (câmera)
    const v = [
        1,0,0,0,
        0,1,0,0,
        0,0,1,0,
        -camPos[0], -camPos[1], -camPos[2], 1
    ];
    gl.uniformMatrix4fv(gl.getUniformLocation(program,"view"),false,new Float32Array(v));

    gl.drawArrays(gl.TRIANGLES,0,vertices.length/3);
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
