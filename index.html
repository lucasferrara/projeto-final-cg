<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo - Restaurante</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: sans-serif;
            display: flex;
        }
        #container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }
        .player-view {
            flex: 1;
            position: relative;
            border-right: 2px solid #333;
        }
        .player-view:last-child {
            border-right: none;
        }
        canvas { 
            width: 100%; 
            height: 100%; 
            display: block; 
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            font-size: 14px;
        }
        .info h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
        }
        .info p {
            margin: 3px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="player-view">
            <div class="info">
                <h3>Jogador 1</h3>
                <p>WASD: Mover</p>
                <p>Espaço: Pular</p>
            </div>
            <canvas id="canvas1"></canvas>
        </div>
        <div class="player-view">
            <div class="info">
                <h3>Jogador 2</h3>
                <p>Setas: Mover</p>
                <p>Enter: Pular</p>
            </div>
            <canvas id="canvas2"></canvas>
        </div>
    </div>

    <script src="Personagens/m4.js"></script>
    <script>
// ================== SETUP ====================
const canvas1 = document.getElementById("canvas1");
const canvas2 = document.getElementById("canvas2");
const gl1 = canvas1.getContext("webgl");
const gl2 = canvas2.getContext("webgl");

function resize() {
    const width = window.innerWidth / 2;
    const height = window.innerHeight;
    
    canvas1.width = width;
    canvas1.height = height;
    gl1.viewport(0, 0, width, height);
    
    canvas2.width = width;
    canvas2.height = height;
    gl2.viewport(0, 0, width, height);
}
resize();
window.onresize = resize;

if (!gl1 || !gl2) alert("WebGL não suportado");

// =============== SHADERS =====================
const vsSrc = `
attribute vec3 position;
attribute vec3 color;
attribute vec3 normal;
uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;
uniform vec3 lightDir;
varying vec3 vColor;
void main() {
    vec3 norm = normalize(mat3(model) * normal);
    float light = max(dot(norm, lightDir), 0.0) * 0.7 + 0.3;
    vColor = color * light;
    gl_Position = projection * view * model * vec4(position, 1.0);
}
`;

const fsSrc = `
precision mediump float;
varying vec3 vColor;
void main() {
    gl_FragColor = vec4(vColor, 1.0);
}
`;

function compile(src,type,gl){
    const s = gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    return s;
}

// Criar programas para ambos os contextos
const vs1 = compile(vsSrc,gl1.VERTEX_SHADER, gl1);
const fs1 = compile(fsSrc,gl1.FRAGMENT_SHADER, gl1);
const program1 = gl1.createProgram();
gl1.attachShader(program1,vs1);
gl1.attachShader(program1,fs1);
gl1.linkProgram(program1);
gl1.useProgram(program1);

const vs2 = compile(vsSrc,gl2.VERTEX_SHADER, gl2);
const fs2 = compile(fsSrc,gl2.FRAGMENT_SHADER, gl2);
const program2 = gl2.createProgram();
gl2.attachShader(program2,vs2);
gl2.attachShader(program2,fs2);
gl2.linkProgram(program2);
gl2.useProgram(program2);

// =============== GEOMETRIA ===============
let vertices = [];
let colors = [];
let normals = [];

function quad(a,b,c,d,color){
    let v1 = [b[0]-a[0], b[1]-a[1], b[2]-a[2]];
    let v2 = [c[0]-a[0], c[1]-a[1], c[2]-a[2]];
    let normal = [
        v1[1]*v2[2] - v1[2]*v2[1],
        v1[2]*v2[0] - v1[0]*v2[2],
        v1[0]*v2[1] - v1[1]*v2[0]
    ];
    let len = Math.sqrt(normal[0]*normal[0] + normal[1]*normal[1] + normal[2]*normal[2]);
    normal = [normal[0]/len, normal[1]/len, normal[2]/len];
    
    vertices.push(...a, ...b, ...c,  ...a, ...c, ...d);
    for (let i=0;i<6;i++) {
        colors.push(...color);
        normals.push(...normal);
    }
}

// Piso
quad([-5,0,0],[5,0,0],[5,0,-80],[-5,0,-80],[0.82,0.82,0.75]);

// Teto
quad([-5,6,0],[5,6,0],[5,6,-80],[-5,6,-80],[0.9,0.88,0.85]);

// Paredes
quad([-5,0,0],[-5,6,0],[-5,6,-80],[-5,0,-80],[0.95,0.9,0.85]);
quad([5,0,0],[5,6,0],[5,6,-80],[5,0,-80],[0.95,0.9,0.85]);
quad([-5,0,-80],[5,0,-80],[5,6,-80],[-5,6,-80],[0.95,0.95,0.95]);

// ============ OBJETO MESA 3D =============
function addCube(x,y,z, w,h,d, color) {
    const v = [
        [x-w, y-h, z-d], [x+w, y-h, z-d], [x+w, y+h, z-d], [x-w, y+h, z-d],
        [x-w, y-h, z+d], [x+w, y-h, z+d], [x+w, y+h, z+d], [x-w, y+h, z+d],
    ];
    quad(v[0],v[1],v[2],v[3],color);
    quad(v[1],v[5],v[6],v[2],color);
    quad(v[5],v[4],v[7],v[6],color);
    quad(v[4],v[0],v[3],v[7],color);
    quad(v[3],v[2],v[6],v[7],color);
    quad(v[0],v[4],v[5],v[1],color);
}

function addRotatedCube(x, y, z, w, h, d, color, rotation) {
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);
    
    const corners = [
        [-w, -h, -d], [w, -h, -d], [w, h, -d], [-w, h, -d],
        [-w, -h, d], [w, -h, d], [w, h, d], [-w, h, d]
    ];
    
    const tCorners = corners.map(p => {
        const rx = p[0] * cos - p[2] * sin;
        const rz = p[0] * sin + p[2] * cos;
        return [x + rx, y + p[1], z + rz];
    });
    
    const v = tCorners;
    quad(v[0],v[1],v[2],v[3],color);
    quad(v[1],v[5],v[6],v[2],color);
    quad(v[5],v[4],v[7],v[6],color);
    quad(v[4],v[0],v[3],v[7],color);
    quad(v[3],v[2],v[6],v[7],color);
    quad(v[0],v[4],v[5],v[1],color);
}

function addTable(x,z){
    const tableColor = [0.7,0.4,0.2];
    const legColor = [0.4,0.25,0.15];
    addCube(x, 0.85, z, 0.7, 0.1, 0.7, tableColor);
    const h = 0.8, s = 0.05;
    addCube(x-0.55, h/2, z-0.55, s, h/2, s, legColor);
    addCube(x+0.55, h/2, z-0.55, s, h/2, s, legColor);
    addCube(x-0.55, h/2, z+0.55, s, h/2, s, legColor);
    addCube(x+0.55, h/2, z+0.55, s, h/2, s, legColor);
}

// Distribuição de mesas
for (let i = 6; i < 75; i += 8) {
    addTable(-2, -i);
    addTable( 2, -i - 3);
}

// Guardar o tamanho inicial do cenário (sem personagens)
const sceneVertexCount = vertices.length;

// ============ PERSONAGENS =============
function addCharacter(px, pz, skinColor, shirtColor, pantsColor, hairColor, eyeColor, rotation = 0, walkTime = 0, py = 0) {
    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);

    function drawPart(rx, ry, rz, w, h, d, col) {
        const worldX = px + (rx * cos - rz * sin);
        const worldZ = pz + (rx * sin + rz * cos);
        const worldY = py + ry;
        addRotatedCube(worldX, worldY, worldZ, w, h, d, col, rotation);
    }

    const legAmp = 0.2;
    const legL = Math.sin(walkTime) * legAmp;
    const legR = Math.sin(walkTime + Math.PI) * legAmp;
    const armL = Math.sin(walkTime + Math.PI) * legAmp;
    const armR = Math.sin(walkTime) * legAmp;

    // Head
    drawPart(0, 2.4, 0, 0.4, 0.4, 0.4, skinColor);
    // Hair
    drawPart(0, 2.75, 0, 0.45, 0.1, 0.45, hairColor);
    drawPart(0, 2.5, -0.4, 0.45, 0.3, 0.05, hairColor);
    // Eyes
    drawPart(-0.15, 2.5, 0.4, 0.1, 0.08, 0.02, [1,1,1]);
    drawPart(0.15, 2.5, 0.4, 0.1, 0.08, 0.02, [1,1,1]);
    drawPart(-0.15, 2.5, 0.41, 0.05, 0.05, 0.02, eyeColor);
    drawPart(0.15, 2.5, 0.41, 0.05, 0.05, 0.02, eyeColor);
    // Mouth
    drawPart(0, 2.2, 0.4, 0.15, 0.04, 0.02, [0.4,0.2,0.1]);

    // Body
    drawPart(0, 1.5, 0, 0.4, 0.5, 0.2, shirtColor);

    // Arms
    drawPart(-0.5, 1.5, armL, 0.15, 0.5, 0.15, skinColor);
    drawPart(0.5, 1.5, armR, 0.15, 0.5, 0.15, skinColor);

    // Legs
    drawPart(-0.15, 0.5, legL, 0.15, 0.5, 0.15, pantsColor);
    drawPart(0.15, 0.5, legR, 0.15, 0.5, 0.15, pantsColor);
    
    // Feet
    drawPart(-0.15, 0.1, legL, 0.18, 0.1, 0.18, [0.1,0.1,0.1]);
    drawPart(0.15, 0.1, legR, 0.18, 0.1, 0.18, [0.1,0.1,0.1]);
}

// ============== POSIÇÕES DOS JOGADORES ==================
let player1 = { x: -1, y: 0, z: -5, vy: 0, rotation: Math.PI, walkTime: 0 };
let player2 = { x: 1, y: 0, z: -5, vy: 0, rotation: Math.PI, walkTime: 0 };

// Adicionar personagens iniciais
addCharacter(player1.x, player1.z, [0.9, 0.7, 0.6], [0.0, 0.6, 0.7], [0.2, 0.2, 0.7], [0.25, 0.15, 0.1], [0.2, 0.2, 0.8], player1.rotation, player1.walkTime, player1.y);
addCharacter(player2.x, player2.z, [0.95, 0.8, 0.7], [0.8, 0.1, 0.1], [0.3, 0.3, 0.3], [0.9, 0.8, 0.2], [0.0, 0.6, 0.0], player2.rotation, player2.walkTime, player2.y);

// =============== BUFFERS ===============
function setupBuffers(gl, program) {
    const vertexData = new Float32Array(vertices);
    const colorData = new Float32Array(colors);
    const normalData = new Float32Array(normals);

    const bPos = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, bPos);
    gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
    const aPos = gl.getAttribLocation(program, "position");
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aPos);

    const bCol = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, bCol);
    gl.bufferData(gl.ARRAY_BUFFER, colorData, gl.STATIC_DRAW);
    const aCol = gl.getAttribLocation(program, "color");
    gl.vertexAttribPointer(aCol, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aCol);

    const bNorm = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, bNorm);
    gl.bufferData(gl.ARRAY_BUFFER, normalData, gl.STATIC_DRAW);
    const aNorm = gl.getAttribLocation(program, "normal");
    gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aNorm);

    return { bPos, bCol, bNorm };
}

let buffers1 = setupBuffers(gl1, program1);
let buffers2 = setupBuffers(gl2, program2);

// ============== CONTROLES ==================
const keys = {};
window.addEventListener('keydown', e => keys[e.key] = true);
window.addEventListener('keyup', e => keys[e.key] = false);

function updatePhysics() {
    const speed = 0.1;
    const autoSpeed = 0.15;
    const jumpForce = 0.2;
    const gravity = 0.01;

    // Player 1
    let dx1 = 0;
    // Auto-run
    player1.z -= autoSpeed;
    
    if (keys['a'] || keys['A']) { dx1 -= speed; }
    if (keys['d'] || keys['D']) { dx1 += speed; }
    
    player1.x += dx1;
    // Rotation based on lateral movement + forward movement
    // Forward is -Z. If moving left (-X), angle is slightly left.
    // atan2(dx, dz): dz is always -autoSpeed
    player1.rotation = Math.atan2(dx1, -autoSpeed);
    player1.walkTime += 0.2;

    if (keys[' '] && player1.y === 0) {
        player1.vy = jumpForce;
    }
    
    player1.y += player1.vy;
    player1.vy -= gravity;
    if (player1.y < 0) {
        player1.y = 0;
        player1.vy = 0;
    }

    // Player 2
    let dx2 = 0;
    // Auto-run
    player2.z -= autoSpeed;

    if (keys['ArrowLeft']) { dx2 -= speed; }
    if (keys['ArrowRight']) { dx2 += speed; }

    player2.x += dx2;
    player2.rotation = Math.atan2(dx2, -autoSpeed);
    player2.walkTime += 0.2;

    if (keys['Enter'] && player2.y === 0) {
        player2.vy = jumpForce;
    }

    player2.y += player2.vy;
    player2.vy -= gravity;
    if (player2.y < 0) {
        player2.y = 0;
        player2.vy = 0;
    }

    // Bounds (Lateral only)
    player1.x = Math.max(-4.5, Math.min(4.5, player1.x));
    player2.x = Math.max(-4.5, Math.min(4.5, player2.x));
}

// ============== GERAR CENÁRIO DINÂMICO ==================
function generateScene(refZ) {
    vertices = [];
    colors = [];
    normals = [];

    // Gerar chão/teto/paredes em torno do jogador de forma contínua
    // Usamos refZ diretamente para que o chão se mova suavemente com o jogador
    const viewDist = 150;
    const backDist = 20;
    const startZ = refZ + backDist;
    const endZ = refZ - viewDist;

    // Piso
    quad([-5,0,startZ],[5,0,startZ],[5,0,endZ],[-5,0,endZ],[0.82,0.82,0.75]);
    // Teto
    quad([-5,6,startZ],[5,6,startZ],[5,6,endZ],[-5,6,endZ],[0.9,0.88,0.85]);
    // Paredes
    quad([-5,0,startZ],[-5,6,startZ],[-5,6,endZ],[-5,0,endZ],[0.95,0.9,0.85]);
    quad([5,0,startZ],[5,6,startZ],[5,6,endZ],[5,0,endZ],[0.95,0.9,0.85]);

    // Mesas (Obstáculos)
    // Alinhar obstáculos a uma grade fixa no mundo para evitar que eles "deslizem" ou pulem
    const spacing = 8;
    // Encontrar o primeiro índice de obstáculo dentro do alcance visível
    // Queremos z = i * spacing tal que z <= startZ
    let firstIndex = Math.floor(startZ / spacing);
    
    for (let i = firstIndex; i * spacing > endZ; i--) {
        let z = i * spacing;
        // Usar o índice como semente para garantir que o obstáculo seja sempre o mesmo naquela posição
        const seed = Math.abs(i);
        const pattern = seed % 3; 
        
        if (pattern === 0) {
            addTable(-2, z);
        } else if (pattern === 1) {
            addTable(2, z);
        } else {
            addTable(-2, z);
            addTable(2, z);
        }
    }
}

// ============== ATUALIZAR GEOMETRIA ==================
function updateCharacters() {
    // Regenerar cenário baseado na posição do Player 1 (assumindo que estão próximos)
    generateScene(player1.z);

    addCharacter(player1.x, player1.z, [0.9, 0.7, 0.6], [0.0, 0.6, 0.7], [0.2, 0.2, 0.7], [0.25, 0.15, 0.1], [0.2, 0.2, 0.8], player1.rotation, player1.walkTime, player1.y);
    addCharacter(player2.x, player2.z, [0.95, 0.8, 0.7], [0.8, 0.1, 0.1], [0.3, 0.3, 0.3], [0.9, 0.8, 0.2], [0.0, 0.6, 0.0], player2.rotation, player2.walkTime, player2.y);
    
    const vertexData = new Float32Array(vertices);
    const colorData = new Float32Array(colors);
    const normalData = new Float32Array(normals);
    
    gl1.bindBuffer(gl1.ARRAY_BUFFER, buffers1.bPos);
    gl1.bufferData(gl1.ARRAY_BUFFER, vertexData, gl1.STATIC_DRAW);
    gl1.bindBuffer(gl1.ARRAY_BUFFER, buffers1.bCol);
    gl1.bufferData(gl1.ARRAY_BUFFER, colorData, gl1.STATIC_DRAW);
    gl1.bindBuffer(gl1.ARRAY_BUFFER, buffers1.bNorm);
    gl1.bufferData(gl1.ARRAY_BUFFER, normalData, gl1.STATIC_DRAW);
    
    gl2.bindBuffer(gl2.ARRAY_BUFFER, buffers2.bPos);
    gl2.bufferData(gl2.ARRAY_BUFFER, vertexData, gl2.STATIC_DRAW);
    gl2.bindBuffer(gl2.ARRAY_BUFFER, buffers2.bCol);
    gl2.bufferData(gl2.ARRAY_BUFFER, colorData, gl2.STATIC_DRAW);
    gl2.bindBuffer(gl2.ARRAY_BUFFER, buffers2.bNorm);
    gl2.bufferData(gl2.ARRAY_BUFFER, normalData, gl2.STATIC_DRAW);
}

// ============== RENDERIZAR ==================
function renderView(gl, program, canvas, playerPos) {
    gl.clearColor(0.1, 0.1, 0.15, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.enable(gl.DEPTH_TEST);

    const projection = m4.perspective(degToRad(60), canvas.width/canvas.height, 0.1, 200);
    gl.uniformMatrix4fv(gl.getUniformLocation(program, "projection"), false, projection);

    const cameraDistance = 3;
    const cameraHeight = 2.5;
    const cameraPosition = [playerPos.x, cameraHeight, playerPos.z + cameraDistance];
    const target = [playerPos.x, 1.5, playerPos.z - 2];
    const up = [0, 1, 0];
    
    const cameraMatrix = m4.lookAt(cameraPosition, target, up);
    const viewMatrix = m4.inverse(cameraMatrix);
    gl.uniformMatrix4fv(gl.getUniformLocation(program, "view"), false, viewMatrix);

    const model = m4.identity();
    gl.uniformMatrix4fv(gl.getUniformLocation(program, "model"), false, model);

    const lightDir = m4.normalize([0.5, 0.7, 1.0]);
    gl.uniform3fv(gl.getUniformLocation(program, "lightDir"), lightDir);

    gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 3);
}

// ============== LOOP ==================
function draw() {
    updatePhysics();
    updateCharacters();
    renderView(gl1, program1, canvas1, player1);
    renderView(gl2, program2, canvas2, player2);
    requestAnimationFrame(draw);
}

draw();
    </script>
</body>
</html>
